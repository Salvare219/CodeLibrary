//一，普通
//(a/b) mod m 等于 a%(b*m)/b   //a不能先取模
//二，逆元
//1. e_gcd 取逆元
//调用 e_gcd(a,b,inv,d);
//inv 为 a 模 b 的逆元  
//即有 (num/a)%b = (num*inv)%b;
//
//2. 欧拉函数取逆元
//费马定理 a^(p-1)=1(mod p) p 素数
//欧拉定理 a^phi[p]=1(mod p) a 与 p 互素
//
//3. 快速幂取逆元
//%1 如果 mod 为素数  有 inv=pow_mod(a,mod-2,mod);
//%2 任意互素数 有 inv=pow_mod(a,phi[mod]-1,mod);
//
//4. 不互素
//其实只需要把答案看做两部分的乘积：一部分是与 m 互素的，这一部分的乘法直接计算，
//除法改成乘逆元就行了；另一部分是若干个 m 的素因子的乘积，因为 m<1,000,000,000 ，
//所以 m 的不同素因子不会太多，用一个数组记录每一个素因子的数量就行。这一部分的
//乘法就是把记录的素因子数量相加，除法就是把记录的素因子数量相减。最后计算这两
//部分的乘积对 m 的取模，也就是 h(n)%m
//
//5. 线性求逆元
//f[i] 为 i 的逆元
fac[0]=inv[0]=f[0]=1;
fac[1]=inv[1]=f[1]=1;
for(int i=2;i<10100005;i++)
{
	f[i]=(-mod/i)*f[mod%i]%mod;
	if(f[i]<0)f[i]+=mod;
	inv[i]=inv[i-1]*f[i]%mod;
	fac[i]=fac[i-1]*i%mod;
}